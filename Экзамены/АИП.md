#### 1) Понятие алфавита языка. Понятие лексемы языка, типы лексем (с пояснениями для каждого типа). Типы констант языка С++, примеры. Управляющие последовательности.**
![[Pasted image 20221120153126.png]]
![[Pasted image 20221120155007.png]]
![[Pasted image 20221120155134.png]]
#### 2) Понятие переменной и типа данных. Основные типы данных языка С++
_**Переменная**_ — это «ячейка» оперативной памяти компьютера, в которой может храниться какая-либо информация.
_**Тип данных**_ - характеристика набора данных, которая определяет: диапазон возможных значений данных из набора; допустимые операции, которые можно выполнять над этими значениями; способ хранения этих значений в памяти.
![[Pasted image 20221120161228.png]]
_**Спецификаторы**_ - это условные обозначения, позволяющие считать из входящего потока определенную конструкцию и сохранить ее
![[Pasted image 20221120162055.png]]
#### 3) Структура программы на языке С++. Понятие директивы препроцессора. Директивы `#include`, `#define` и примеры их использования. Использование модулей и заголовочных файлов. Этапы сборки проекта. Комментарии.
![[Pasted image 20221120163124.png]]
![[Pasted image 20221120163147.png]]
_**Препроцессор**_ — это специальная программа, являющаяся частью компилятора языка Си. Она предназначена для предварительной обработки текста программы. Препроцессор позволяет включать в текст программы файлы и вводить макроопределения.  
Работа препроцессора осуществляется с помощью специальных _директив_ (указаний). Они отмечаются знаком решетка #. По окончании строк, обозначающих директивы в языке Си, точку с запятой можно не ставить.
![[Pasted image 20221120162543.png]]
**`#define`**, пример использоания
![[Pasted image 20221120162724.png]]
![[Pasted image 20221120163252.png]]
_**В языках программирования Си и C++ заголовочные файлы**_ — основной способ подключить к программе типы данных, структуры, прототипы функций, перечисляемые типы и макросы, используемые в другом модуле. По умолчанию используется расширение .h
![[Pasted image 20221120163926.png]]
_**Этапы сборки проекта**_
https://habr.com/ru/post/478124/
_**Комментарии**_ предназначены для записи пояснений к программе и формирования документации. Компилятор комментарии игнорирует. Внутри комментария можно использовать любые символы. В C# есть два вида комментариев: однострочные и многострочные.
#### 4) Оператор присваивания (все возможные варианты записи оператора). Понятие потока. Поточный ввод и вывод данных. Примеры ввода и вывода. Понятие пространства имен. Форматированный вывод. Манипуляторы ввода-вывода. Примеры использования манипуляторов.
_Команда **присваивания** позволяет задавать значения переменным или менять их значение_
![[Pasted image 20221120170053.png]]
![[Pasted image 20221120170120.png]]
**Потоки в С++**
По сути, ввод/вывод в языке C++ реализован с помощью потоков. Абстрактно, _**поток**_ — это _последовательность символов, к которым можно получить доступ_. Со временем поток может производить или потреблять потенциально неограниченные объемы данных.

**Пространство имен** — это декларативная область, в рамках которой определяются различные идентификаторы (имена типов, функций, переменных, и т.д.).

**Форматированный ввод/вывод данных, манипуляторы**
https://kvodo.ru/urok-10-formatirovannyiy-vvod-vyivod-v-c.html

#### 5) Понятие операнда, операции и выражения. Унарные и бинарные операции в С++. Тернарная операция. Примеры применения всех операций и результат их работы.
_**Операнд**_ в математике и в языках программирования ― **аргумент операции; данные, которые обрабатываются командой; математическое выражение, задающее значение аргумента операции**. Иногда операндом называют место, позицию в тексте, где должен стоять аргумент операции

_**Операция**_ — **конструкция в языках программирования, аналогичная по записи математическим операциям, то есть специальный способ записи некоторых действий**. Наиболее часто применяются арифметические, логические и строковые операции.

**Выражение** -- последовательность действий над данными, приводящая к каком-то результату

_**Унарные операции**_ - это декремент и инкремент (действие производится с одним операндом (пример, a++, --b, знак (!), &, * , -, sizeof() )

_**Бинарные операции**_  - это операции с двумя операндами, такие как +, -, ||, &&, >>, <<

_**Тернарная операия**_
![[Pasted image 20221122184354.png]]

#### 6) Понятие приоритета операций и ассоциативности. Приоритеты выполнения операций в С++ (перечислить все операции по убыванию приоритета с указанием ассоциативности). Математические функции и константы. Генератор случайных чисел. Примеры генерации чисел из случайного диапазона, пример генерации вещественных чисел.

_**Приоритет операций**_ — очерёдность выполнения **операций** в выражении, при условии, что в выражении нет явного указания порядка следования выполнения **операций**

_**Ассоциативность**_ - направление выполнения операций в случае, если операции имеют одинаковый приоритет

![[Pasted image 20221122185214.png]]

![[Pasted image 20221122185547.png]]
![[Pasted image 20221122185945.png]]
![[Pasted image 20221122190235.png]]

#### 7) Понятие указателя. Операции взятия адреса и разыменования. Понятие статических и динамических переменных. Операции выделения и освобождения памяти. Присваивание указателей. Примеры.

_**Указатель**_ - это переменная хранящая адре на ячейку в оперативной памяти.
_операция взятия адреса_ &
_операция разыменования_ *

_Статические переменные_ имеют фиксированную память, которую выделили под них. Это количество памяти не может быть изменено в ходе работы программы.
_Динамические переменные_ имеют нефиксированное количество памяти и хранят в себе ссылку на ячейку в памяти. Кол-во памяти может изменятся в ходе работы программы.

**new** - выделение памяти
**delete** освобождение памяти

присваиание указателей:
```c++
int a = 9;
int *pa = &a;

int *array = new int[];
```

#### 8) Операторы ветвления и варианта. Примеры применения операторов ветвления и варианта (постановка задачи и код программ на С++).
*Ветвления* - if / else / else if
*Варианта*
![[Pasted image 20221122191458.png]]

#### 9) Оператор цикла с параметром. Нахождение суммы ряда с использованием формулы общего члена ряда, с использованием рекуррентной формулы и смешанной формулы. Примеры нахождения суммы ряда для каждого варианта (с приведением кода программ).

**Цикл for** - цикл с параметром

```c++
int n = 10;
int sum = 0;
for(int i = 1; i < n; i++)
{
	sum += pow(2, n) * (2*n + 1);
}
```
![[Pasted image 20221126124232.png]]
![[Pasted image 20221126124323.png]]
_**рекуррентное соотношение**_ — это уравнение, согласно которому n-й член последовательности чисел равен некоторой комбинации предыдущих членов.



#### 10) Оператор цикла с предусловием. Особенности цикла. Поиск наибольшего общего делителя. Алгоритм Евклида (обычный и модифицированные варианты). Примеры нахождения НОД с помощью данного алгоритма. Реализация всех разновидностей алгоритма Евклида на С++.

_**Оператор цикла с предусловием**_
```c++
while(условие)
{
	выражение;
}
```
параметр, подаваемый в условие объязательно должен изменятся в ходе работы цикла, иначе цикл будет работать бесконечно
![[Pasted image 20221126130709.png]]

**НОД** - это максимальное число из всех общих делителей данных чисел

**Алгоритм Евклида** 
![[Pasted image 20221126131030.png]]
![[Pasted image 20221126131314.png]]

**Модифицированный алгоритм Евклида**
![[Pasted image 20221126131330.png]]
![[Pasted image 20221126131341.png]]

#### 11) Оператор цикла с постусловием. Особенности цикла с постусловием. Определение простоты числа с использованием цикла с постусловием (постановка задачи и реализация на С++). Операторы break и continue. Примеры использования (код на С++).

**Цикл с постусловием** — цикл, в котором *условие проверяется после выполнения тела цикла*. Отсюда следует, что тело всегда выполняется хотя бы один раз.
```c++
do
{
	выражение;
} while(условие);
```

Простота числа
![[Pasted image 20221126133608.png]]
![[Pasted image 20221126133803.png]]
![[Pasted image 20221126133823.png]]

#### 12) Оценка временной сложности алгоритмов. Методы повышения эффективности алгоритмов, примеры (код программ на С++).

![[Pasted image 20221126134414.png]]
![[Pasted image 20221126134542.png]]

#### 13) Понятие текстового файла и особенности работы с ним. Чтение и запись в текстовые файлы. Примеры использования текстовых файлов (код программы на С++).
![[Pasted image 20221126135242.png]]

Чтение и запись данных в файл производятся с помощью потоков ввода и вывода
*Поток* - непрерывная строка символов

подключаем библиотеку fstream
**ofstream** - поток записи в файл
**ifstream** - поток чтения из файла

```c++
ofstream fwrite; //создание объекта
fwrite.open("file.txt"); //откртие файла
...
fwrite.close(); //закрытие файла
```
![[Pasted image 20221126140743.png]]
для чтения символа из файла или записи в файл можно использовать 
оператор >>, << 
для чтения строки используется метод getline(), read()
для получения строки символов метод gets_s()
для определения конца файла метод eof()

#### 14) Понятие функции. Способы передачи параметров в функцию (три варианта). Оператор return. Пример использования функций (постановка задачи и код на С++)

*Функция в программировании* представляет собой обособленный часть кода, который можно вызывать из любой части программы и сколько угодно раз, обратившись к нему по имени, которым он был назван.
![[Pasted image 20221127155940.png]]

**Способы передачи параметрвов в функцию**
1) По значение (в функцию подаётся копия данных и функция работает именно с копией, поэтому значения исходных аргументов не меняются)
2) По ссылке (в функцию передаётся ссылка на ячейку памяти, где храниятся данные той переменной, которую мы подаём в функцию)
3) По указателю (этот способ аналогичен способу передачи параметров с помощью ссылки, только функция получает указатель, который ссылается на ту же ячейку в памяти)
![[Pasted image 20221127160621.png]]

#### 15) Прототипы функций и причины их использования. Перегрузка функций. Передача параметров по умолчанию. Примеры. Локальные и глобальные переменные.
**Прототип функции** - это функция, не содержащая тела функции. Он стоит из типа возвращаемых данных, названия и списка переменных.
Объявлеяется перед главной функцией, но его тело описывается после главной функции.
**Причина использования** - отладка программы, чтобы компилятор знал, что есть некая функция и её параметры. Следовательно при её неправильном использовании программист будет знать, где и какая произошла ошибка.

**Перегрузка функций** - механизм, когда можно вызвать функцию одного имени несколько раз и подать данные разных типов. Для этого придётся объявить и описать две функции с одинаковыми названиями, но с разными типами данных.
![[Pasted image 20221127163144.png]]

**Передача параметров по умолчанию**
Если есть вероятность, что в функцию не будет передан какой-то из параметров, то при объявлении функции в ней можно указать параметр, задать его тип и значение.
Тогда если функция не получит этот параметр, то она будет использовтаь тот, который был указан по умолчанию.
![[Pasted image 20221127162533.png]]

Переменные, описанные внутри функции, а также переменные из списка аргументов, являются **локальными**
Переменные, описанные вне функций являются **глобальными**
![[Pasted image 20221127162908.png]]

#### 16) Рекурсия. Способы выполнения действий в рекурсивной функции (на спуске, на возврате, смешанный). Примеры рекурсивных функций всех трех типов (реализация на С++). Косвенная рекурсия.

![[Pasted image 20221127163056.png]]

1.  Форма с выполнением действий до рекурсивного вызова (с выполнением действий **на рекурсивном спуске**).
2.  Форма с выполнением действий после рекурсивного вызова (с выполнением действий **на рекурсивном возврате**).
3.  Форма с выполнением действий как до, так и после рекурсивного вызова (с выполнением действий, как **на рекурсивном спуске,** так и **на рекурсивном возврате**).

Косвенная рекурсия **создаётся за счёт вызова данной функции из какой-либо другой функции, которая сама вызывалась из данной функции**. Например, схема может быть такой: Как видим, в main() вызывается функция A(), которая вызывает B(), а та в свою очередь вызывает снова A().

#### 17) Одномерные массивы: описание и инициализация массивов, виды доступа к элементам массива, динамическое выделение памяти под массивы, способы передачи массива в функцию. Ввод и вывод элементов массива. Пример использования одномерных массивов (постановка задачи и реализация на С++)

**Статический массив**
```c++
int arr[5] = {4, 3, 5, 65, 45};
```
к элементами можно обращаться через индекс, либо через указатель
индекс: 
```c++
int arr[5] = {4, 3, 5, 65, 45};
arr[1] = 1;
```
указатель:
```c++
int arr[5] = {4, 3, 5, 65, 45};
*(arr + 1) = 1;
```
**Динамичекий массив**
```c++
int *arr = new int[5]{4, 3, 5, 65, 45};
```

*Способы передачи массива в функцию*:
1) передача в функцию массива (int arr[]) - это не копия, а указатель на первую ячейку, поэтому мы не можем получить длину этого массива стандартными методами
2) передача в функцию массива и его длины (int arr[], int n)
3) передача в функцию указателя на массив (int* arr) 
4) передача ссылки на указатель (int * &arr), это нужно, чтобы можно было перезаписать ссылку на указатель, если потребуется удалить старый массив и создать вместо него новый

**Запись элементов в массив**
```c++
int arr[5];
for(int i = 0; i < 5; i++)
{
	arr[i] = i * i;
}
```
**Получение элементов из массива**
```c++
int arr[5];
for(int i = 0; i < 5; i++)
{
	cout << arr[i] << endl;
}
```

#### 18) Операции над одномерными массивами: поиск элемента с заданным значением, удаление одного элемента из массива, вставка одного элемента в массив (реализация на С++).

**Поиск элемента**
```c++
int arr[5] = {3, 5, 0, 6, 4};
int n = 6;
for(int i = 0; i < 5; i++)
{
	if(arr[i] == n) cout << arr[i];
}
```
![[Pasted image 20221127181656.png]]
![[Pasted image 20221127181722.png]]

#### 19) Удаление и вставка нескольких элементов в одномерный массив (постановка задачи и реализация на С++).

#### 20) Работа со строками как с массивом символов (в формате языка С). Ввод и вывод строк. Преобразование строк в число и числа в строку. Обработка символов строки. Пример использования строк как массива символов (постановка задачи и код на С++).
**Работа со строками на Си**
чтение строки
```c++
char str[100];
scanf("%s", str);
```
вывод строки
```c++
char str[100];
printf("%s\n", str);
```
cимвол в число
```c++
char s = '5';
int a = s - '0';
```
строка символов в число
```c++
char s[10] = {'7', '5', '3', '3'};
    int a = 0;
    for (int i = 0; i < strlen(s); i++)
    {
        a += s[i] - '0';
        if (i < strlen(s) - 1) a *= 10;
    }
```
**обработка строки**
перебор как массива
обращение как к элементам массива

....

#### 21) Класс string: описание, инициализация, основные методы (с примерами). Преобразование строки из типа string в строку в формате С и наоборот.

**Работа со строками  С++**
Класс _string_ предназначен для работы со строками типа _char*_, которые представляют собой строку с завершающим нулем. *Класс string был введенн как альтернативный вариант для работы со строками типа char*. Строки, которые завершаются символом ‘\0’ еще называются _C-строками_. Поскольку, string есть классом, то можно объявлять объекты этого класса.

подключение библиотеки 
```c++
#include <string>;
```
инициализация
```c++
string s1 = "hello";
string s2("Hey");

char* ps = "Hello"; //с помощью указателя;
string s3(ps);
```
чтение строки
```c++
char str[100];
gets_s(str);
```
вывод строки
```c++
char str[100];
puts(str);
```
строка в число
```c++
string s = "535564";
int a = stoi(s);
```
число в троку
```c++
int a = 3454567;
string s = to_string(a);
```

**Основые методы**
```c++
// чтение строки из потока ввода
string s;
getline(cin, s);
// длина строки
s.length(); 
s.size();
s.clear(); //очистка
s.empty(); //проверка на пустоту
s.push_back(с); //добавления в конец строки переменной c
s.append(); //добавление в конец строки другой строки, символа или фрагмент строки
s.erase(id, count); //удаление строки с позиции id и кол-во символов
s.insert() //вставка строки
s.substr(pos, count) //возвращение строки
s.replace() //замена частей строк
s.assign() //присванивание
s.find() //поиск по строке
s.compare() //сравнение
```
**из string в char[] Си**
```c++
string s = "hello";
const char* ps = s.c_str(); //ps = "hello"
```
**из char[] в string**
```c++
char s[] = { 't', 'e', 's', 't' };
string str(s, sizeof(s));
```

#### 22) Двумерные массивы: описание массива, выделение памяти под массив, ввод и вывод элементов массива, суммирование элементов массива. (реализация на С++).

**Двумерный массив** - это структура данных, представленная ввиде одномерного массива, хранящего указатели на другие массивы, которые в свою очередь содержат некие данные одного типа.
```c++
int** arr = new int* [10];
for(int i = 0; i < 10; i++)
{
	arr[i] = new int[10];
}
```
**Вывод элементов из массива**
```c++
for (int i = 0; i < 10; i++)
{
    for (int j = 0; j < 10; j++)
    {
        cout << arr[i][j] << " ";
    }
    cout << endl;
}
```
**Ввод элементов в массива**
```c++
for (int i = 0; i < 10; i++)
{
    for (int j = 0; j < 10; j++)
    {
        arr[i][j] = i * j;
    }
}
```
**Cуммирование элементов в массива**
```c++
int sum = 0;
for (int i = 0; i < 10; i++)
{
    for (int j = 0; j < 10; j++)
    {
        sum += arr[i][j];
    }
}
```

#### 23) Операции над двумерными массивами: вставка строки после заданной строки с номером k, удаление строки с номером k, поиск минимального элемента в двумерном массиве (постановка задачи и реализация на С++).



#### 24) Сортировка методом простого обмена. Модифицированный «пузырек» (описание алгоритма, пример применения и реализация метода на С++)

**Сортировка пузырьковым методом** заколючается в многократном прохождении по массиву и если один элемент больше следующего, то они меняются местами
**Количество прохождений** равно длине массива, так как этого достаточно, чтобы самый маленький элемент массива, который находится в конце, переместить на первое место.
```c++
const int len = 10;
    int arr[len] = { 1, 53, -4, 654, 0, 5, 333, 54, 1, -45 };
    for (int i = 0; i < len; i++)
    {
        for (int j = 0; j < len - 1; j++)
        {
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
        }
    }
```
**Модифицированный пузырёк**
Принцип тот же самый, но так как при каждом проходе по массиву гарантированно самый большой элемент переместиться в конец, то при следующем проходе уже незачем рассматривать последний элемент, т.к. он и так уже самый большой.
```c++
const int len = 10;
    int arr[len] = { 1, 53, -4, 654, 0, 5, 333, 54, 1, -45 };
    int n = len;
    for (int i = 0; i < len; i++)
    {
        for (int j = 0; j < n - 1; j++)
        {
            if (arr[j] > arr[j + 1])
                swap(arr[j], arr[j + 1]);
        }
        n--;
    }
```

#### 25) Шейкер-сортировка (описание алгоритма, пример применения и реализация метода на С++)
**Шейкер сортировка** - улучшенная версия пузырька. Идея заключается в том, что при каждом проходе _слева направо_ на последнюю позицию встаёт самый большой элемент, а при проходе _справа налево_ на первую позицию встаёт самый маленький элемент.
Таким образом, мы имеем уже отсортированные участки массива, которое в дальнейшем уже рассматривать не нужно, таким образом количество рассматриваемых элементов в каждом проходе уменьшается на 1.
```c++
const int len = 10;
    int arr[len] = { 1, 53, -4, 654, 0, 5, 333, 54, 1, -45 };
    int n = len;
    int left, right, i;
    left = 0;
    right = n - 1;
    while (left <= right) {
	    //слева направо
        for (i = left; i <= right; i++) {
            if (arr[i - 1] > arr[i]) {
                swap(arr[i - 1], arr[i]);
            }
        }
        right--;
	    //справа налево
        for (i = right; i >= left; i--) {
            if (arr[i - 1] > arr[i]) {
                swap(arr[i - 1], arr[i]);
            }
        }
        left++;
    }
```

#### 26) Метод простых вставок (описание алгоритма, пример применения и реализация метода на С++)

**Метод сортировки простыми вставками** 
алгоритм: 
1)  сравниваем текущий элемент с предыдушим
2)  если текущий больше предыдущего, то ничего не делаем
	  если текущий эл. меньше предыдущего, то перемещаем текущий элемент по массиву назад до тех пор, пока он не станет меньше того элемента, который тоит за ним и вставляем его на это место. Правая часть массива соответственно сдвинется направо на один.
3) 

#### 27) Сортировка простым выбором (описание алгоритма, пример применения и реализация метода на С++)

#### 28) Бинарный поиск элемента в массиве. Сортировка бинарными вставками (описание алгоритмов, примеры применения и реализация метода на С++)
